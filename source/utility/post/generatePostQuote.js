import getPostText from './getPostText'
import trimText from './trimText'

/**
 * Returns post text: first tries without post quotes, then tries with post quotes (unless `skipPostQuoteBlocks: true` option is passed).
 * @param  {object} post
 * @param  {bool} [options.skipPostQuoteBlocks] — Set to `true` to skip post quotes. Post quotes are skipped by default, unless no quote has been generated, in which case the function is re-run with post quotes included (unless instructed otherwise).
 * @param  {function} [options.onUntitledAttachment] — If set, this function will be called with an untitled attachment as an argument in cases when the resulting post quote has to quote such untitled attachment, resulting in something generic like "Picture" or "Video": in such cases, the `attachment` could be displayed instead of such generic label.
 * @return {string} [text]
 */
export default function generatePostQuote(post, _options) {
	const {
		title,
		content,
		attachments
	} = post
	const {
		maxLength,
		fitFactor,
		skipPostQuoteBlocks,
		onUntitledAttachment,
		// cache,
		...rest
	} = _options
	const getPostTextOptions = {
		...rest,
		softLimit: maxLength
	}
	let text
	// If `cache` was to be implemented, then
	// `post._text` and `post._textMaxLength`
	// would have to be reset after `loadResourceLinks()`,
	// and also after an attachment spoiler has been revealed.
	// Also, `onPostLink()` wouldn't get triggered in such case,
	// which would result in incorrect behavior of
	// `canGeneratePostQuoteIgnoringNestedPostQuotes()`.
	// if (cache && post._textMaxLength !== undefined && maxLength <= post._textMaxLength) {
	// 	text = post._text
	// } else {
		// First generated post text skipping all quote blocks and attachments.
		text = getPostText(post, {
			...getPostTextOptions,
			skipPostQuoteBlocks: true,
			skipAttachments: true
		})
		// If no text was generated with the strict conditions,
		// start relaxing the conditions until some text is generated.
		// Start with not skipping attachments having a title.
		if (!text) {
			text = getPostText(post, {
				...getPostTextOptions,
				skipPostQuoteBlocks: true,
				skipAttachments: false,
				skipUntitledAttachments: true,
				skipNonEmbeddedAttachments: false
			})
		}
		// // Then continue with not skipping non-generated post quotes.
		// if (!text) {
		// 	text = getPostText(post, {
		// 		...getPostTextOptions,
		// 		skipGeneratedPostQuoteBlocks: true,
		// 		skipUntitledAttachments: true
		// 	})
		// }
		// Add post title to the text.
		text = addTitle(text, title)
		// If no text was generated, then continue with
		// not skipping untitled attachments.
		if (!text) {
			text = getPostText(post, {
				...getPostTextOptions,
				skipPostQuoteBlocks: true,
				skipAttachments: false,
				skipUntitledAttachments: false,
				skipNonEmbeddedAttachments: false,
				onAttachment: onUntitledAttachment
			})
		}
		// If no text was generated, then continue with not skipping
		// post quote blocks (unless explicitly instructed otherwise).
		if (!text) {
			if (!skipPostQuoteBlocks) {
				text = getPostText(post, getPostTextOptions)
				// If no text was generated, then continue with
				// not skipping autogenerated post quote blocks.
				if (!text) {
					text = getPostText(post, {
						...getPostTextOptions,
						skipGeneratedPostQuoteBlocks: false
					})
				}
			}
		}
	// 	if (cache) {
	// 		post._text = text
	// 		post._textMaxLength = maxLength
	// 	}
	// }
	if (text) {
		// Trim the text to `maxLength` (according to `fitFactor`).
		// Also, compact inter-paragraph margins into just "new line" characters.
		return trimText(
			text.replace(/\n\n+/g, '\n'),
			maxLength,
			{
				countNewLines: true,
				fitFactor
			}
		)
	}
}

function addTitle(text, title) {
	if (!title) {
		return text
	}
	if (text) {
		return title + '\n\n' + text
	} else {
		return title
	}
}

function getFirstAttachment({ content, attachments }) {
	for (const block of content) {
		if (typeof block === 'object' && block.type === 'attachment') {
			const attachment = attachments.find(_ => _.id === block.attachmentId)
			if (attachment) {
				return attachment
			} else {
				console.error(`Attachment ${block.attachmentId} not found`)
			}
		}
	}
	return attachments[0]
}

export function canGeneratePostQuoteIgnoringNestedPostQuotes(post, options) {
	// If the `post` contains inline `post-link`s, then
	// `getPostText({ maxLength })` will include those
	// linked posts' `content`, so it has to be parsed
	// before generating this `post`'s quote.
	let encounteredInlinePostLink
	const text = generatePostQuote(post, {
		...options,
		// `canGeneratePostQuoteIgnoringNestedPostQuotes()`
		// skips all `post-link` block quotes entirely
		// and returns `false` whenever it encounters an
		// inline `post-link` quote. The whole point of
		// `canGeneratePostQuoteIgnoringNestedPostQuotes()`
		// is that it runs before `post-link`s' `content` is even parsed.
		// The only case when a `post-link` has parsed `content`
		// is when those're quotes that have been manually entered
		// by the comment author, but those aren't included in the
		// post quote anyway, because `skipPostQuoteBlocks: false`
		// is passed internally to `generatePostQuote()`.
		// So `post-link`s are ignored entirely by this function,
		// and their `content` has no influence on this function's outcome.
		skipPostQuoteBlocks: true,
		onPostLink: (postLink) => {
			// `postLink._block` flag is set in `setInReplyToQuote()`.
			// `postLink.content[0].block` can't be used there
			// because `postLink.content` is not yet generated
			// because the linked post's `content` hasn't been parsed yet.
			if (!postLink._block) {
				encounteredInlinePostLink = true
			}
		}
	})
	// If there's an inline `post-link` quote that's gonna be part of
	// the resulting post quote generated with the the `maxLength`,
	// then the linked `post`'s `content` has to be parsed first.
	if (encounteredInlinePostLink) {
		return false
	}
	// The `post` is supposed to have some `content`:
	// the calling function checks that before calling
	// this function. Otherwise, there'd be no need
	// to call this function.
	// If the `post` has `content`, but its `text` is empty,
	// then the `content` is assumed to only contain autogenerated
	// block `post-link` quotes, which have all been skipped.
	// If that's the case, then it means that the quoted posts'
	// `content` should be parsed first.
	return text ? true : false
}