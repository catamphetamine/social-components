import getPostText from './getPostText'
import trimText from './trimText'

/**
 * Returns post text: first tries without post quotes, then tries with post quotes (unless `skipPostQuoteBlocks: true` option is passed).
 * @param  {object} post
 * @param  {bool} options.skipPostQuoteBlocks â€” Set to `true` to skip post quotes. Post quotes are skipped on first run, but not on second run (if the first run returned no text).
 * @return {string} [text]
 */
export default function generatePostQuote(post, _options) {
	const { content, attachments } = post
	const {
		maxLength,
		fitFactor,
		countNewLines,
		skipPostQuoteBlocks,
		// cache,
		...rest
	} = _options
	const getPostTextOptions = {
		...rest,
		softLimit: maxLength
	}
	let text
	// If `cache` was to be implemented, then
	// `post._text` and `post._textMaxLength`
	// would have to be reset after `loadResourceLinks()`,
	// and also after an attachment spoiler has been revealed.
	// Also, `onPostLink()` wouldn't get triggered in such case,
	// which would result in incorrect behavior of
	// `canGeneratePostQuoteIgnoringNestedPostQuotes()`.
	// if (cache && post._textMaxLength !== undefined && maxLength <= post._textMaxLength) {
	// 	text = post._text
	// } else {
		text = getPostText({ content, attachments }, {
			...getPostTextOptions,
			skipPostQuoteBlocks: true
		})
		// If the generated post preview is empty
		// then loosen the filters and include post quotes.
		if (!text && !skipPostQuoteBlocks) {
			text = getPostText({ content, attachments }, getPostTextOptions)
		}
	// 	if (cache) {
	// 		post._text = text
	// 		post._textMaxLength = maxLength
	// 	}
	// }
	if (text) {
		// Return the quoted post text abstract.
		// Compacts multiple paragraphs into multiple lines.
		return trimText(
			text.replace(/\n\n+/g, '\n'),
			maxLength,
			{
				countNewLines,
				fitFactor
			}
		)
	}
}

export function canGeneratePostQuoteIgnoringNestedPostQuotes(post, options) {
	// If the `post` contains inline `post-link`s, then
	// `getPostText({ maxLength })` will include those
	// linked posts' `content`, so it has to be parsed
	// before generating this `post`'s quote.
	let encounteredInlinePostLink
	const text = generatePostQuote(post, {
		...options,
		// `canGeneratePostQuoteIgnoringNestedPostQuotes()`
		// skips all `post-link` block quotes entirely
		// and returns `false` whenever it encounters an
		// inline `post-link` quote. The whole point of
		// `canGeneratePostQuoteIgnoringNestedPostQuotes()`
		// is that it runs before `post-link`s' `content` is even parsed.
		// The only case when a `post-link` has parsed `content`
		// is when those're quotes that have been manually entered
		// by the comment author, but those aren't included in the
		// post quote anyway, because `skipPostQuoteBlocks: false`
		// is passed internally to `generatePostQuote()`.
		// So `post-link`s are ignored entirely by this function,
		// and their `content` has no influence on this function's outcome.
		skipPostQuoteBlocks: true,
		onPostLink: (postLink) => {
			// `postLink._block` flag is set in `setInReplyToQuote()`.
			// `postLink.content[0].block` can't be used there
			// because `postLink.content` is not yet generated
			// because the linked post's `content` hasn't been parsed yet.
			if (!postLink._block) {
				encounteredInlinePostLink = true
			}
		}
	})
	// If there's an inline `post-link` quote that's gonna be part of
	// the resulting post quote generated with the the `maxLength`,
	// then the linked `post`'s `content` has to be parsed first.
	if (encounteredInlinePostLink) {
		return false
	}
	// The `post` is supposed to have some `content`:
	// the calling function checks that before calling
	// this function. Otherwise, there'd be no need
	// to call this function.
	// If the `post` has `content`, but its `text` is empty,
	// then the `content` is assumed to only contain autogenerated
	// block `post-link` quotes, which have all been skipped.
	// If that's the case, then it means that the quoted posts'
	// `content` should be parsed first.
	return text ? true : false
}